# 方案：拆分仓库与模块化治理（Flutter + Web 分离）

目标：把当前 repo 中“两个产品/两套运行时”拆开，降低认知负担、减少依赖互相污染、让 CI/CD 与发布路径清晰。

## 1. 现状问题

- `director_ai` 同时包含：
  - Flutter app（移动端）
  - Python/Gradio 工具（web/）
- 两者依赖、运行方式、发布方式完全不同：
  - Flutter：Dart/Gradle/Xcode
  - Web：Python venv + pip + Gradio/FastAPI

副作用：
- 新人不知道从哪里跑起。
- CI 复杂：要么全跑（慢且脆），要么随意跳过（不可靠）。
- 版本与发布无法对齐（移动端 vs Web 工具）。

## 2. 目标结构（推荐）

推荐拆分为两个 repo（或一个 monorepo 的两个顶层 package）：

- `director-ai-mobile`（Flutter）
  - `lib/`, `android/`, `ios/`...
  - 只保留移动端相关文档

- `ai-storyboard-pro-web`（Python/Gradio）
  - `app.py`, `settings.py`, `requirements*`, `Dockerfile`...
  - 专注 Web 工具与 REST API

如果必须保留 monorepo：

```
repo/
├── packages/
│   ├── mobile/   # Flutter
│   └── web/      # Python
├── docs/
└── tools/
```

## 3. 分离策略

### 3.1 Git 历史与迁移

- 简单策略：直接复制目录建立新 repo（最快）。
- 严谨策略：用 `git filter-repo` 保留历史（需要 repo 是干净的且有 git 历史治理需求）。

### 3.2 文档治理

- 每个 repo 有自己的 README：
  - Quick start
  - 配置
  - 常见问题（代理、依赖版本）

- 共享文档（如果需要）放在单独 repo 或者上层 docs 门户。

### 3.3 依赖与运行时隔离

- Web：提供 Dockerfile（可选但强烈建议），避免本机 Python/SSL/代理差异导致不可复现。
- Mobile：提供 `flutter doctor` baseline 版本要求。

### 3.4 API 边界（关键决策点）

需要先决定 Flutter 与 Web 的关系：

A) 完全独立（当前更像这样）
- Flutter 直接调用第三方 AI API。
- Web 是独立工具。

B) Web 作为后端（未来方向）
- Flutter 调用自家 API（web 提供），web 再去调用第三方。
- 需要：鉴权、限流、任务队列、存储。

如果你选 B：建议增加 `contracts/`（OpenAPI/JSON schema）作为契约层。

## 4. CI/CD 方案

### 4.1 Mobile CI

- `flutter analyze`
- `flutter test`
- 构建产物（Android APK/AAB，iOS archive）

### 4.2 Web CI

- `python -m compileall`
- `ruff` / `pytest`（如配置）
- docker build（如果引入）

## 5. 迁移步骤（建议执行顺序）

1) 明确边界决策：A 独立 or B 后端。
2) 把 web 抽到新 repo（或 packages/web），让它自己能跑、有锁定依赖。
3) 把 mobile 抽到新 repo（或 packages/mobile），清理无关文件。
4) 增加顶层说明（如果 monorepo）：贡献指南、开发流程。

## 6. 预估工作量

- 快速拆分（不保历史）：1-2 天
- 保留历史 + CI/CD：3-6 天
- 若转为“web 做后端”：额外 2-6 周（取决于任务队列/存储/鉴权）。

## 7. 风险与缓解

- 风险：拆分后跨 repo 协同成本上升。
  - 缓解：契约/文档 + 版本化发布。
- 风险：web 依赖不可复现。
  - 缓解：lockfile + Docker。

## 8. Done 标准

- 两个 repo（或两个 package）都能独立从零跑起来。
- CI 能分别跑各自的检查。
- README 清楚指引贡献者与发布流程。
